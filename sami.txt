# AGKS - Akƒ±llƒ± G√∂zetim Koruma Sistemi
## Comprehensive Project Documentation Report

================================================================================
                           PROJECT OVERVIEW
================================================================================

Project Name: AGKS (Akƒ±llƒ± G√∂zetim Koruma Sistemi)
English: Intelligent Surveillance Protection System
Version: 2.0
Type: AI-Powered Security Monitoring System
Technologies: Python, Flask, YOLOv8, OpenCV, SQLite, HTML/CSS/JavaScript

DESCRIPTION:
AGKS is an intelligent real-time security surveillance system that uses 
artificial intelligence (specifically YOLOv8 deep learning model) to detect 
potential threats in live camera feeds. The system can identify dangerous 
objects such as guns, knives, and masked individuals (balaclava), and 
automatically triggers alerts, records forensic videos, and sends notifications 
via Telegram.

================================================================================
                           PROJECT STRUCTURE
================================================================================

Project-V2/
‚îÇ
‚îú‚îÄ‚îÄ backend/                      # Backend Flask Application
‚îÇ   ‚îú‚îÄ‚îÄ app/                      # Main Application Package
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py          # Flask Application Factory
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py            # Configuration Management
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py            # HTTP Endpoints (490 lines)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/            # Business Logic Services
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ yolo_service.py      # YOLO Model Management
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ camera_service.py    # Camera Control
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ recorder_service.py  # Video Recording
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ telegram_service.py  # Telegram Notifications
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ threat_logic.py      # Threat Detection Logic
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ database_service.py  # SQLite Database
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/                   # AI Models
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ best.pt              # Custom Trained YOLOv8 Model
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ database/                 # Database Storage
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ alerts.db            # SQLite Database File
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ storage/                  # Video Storage
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ alerts/              # Recorded Alert Videos
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ run.py                   # Application Entry Point
‚îÇ
‚îú‚îÄ‚îÄ frontend/                     # Frontend Web Interface
‚îÇ   ‚îú‚îÄ‚îÄ templates/               # HTML Templates (Jinja2)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.html       # Main Dashboard Page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitor.html         # Live Monitoring Page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alerts.html          # Alerts History Page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settings.html        # System Settings Page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gallery.html         # Video Gallery Page
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.html           # Landing Page
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ static/                  # Static Assets
‚îÇ       ‚îú‚îÄ‚îÄ css/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ style.css        # Main Stylesheet
‚îÇ       ‚îú‚îÄ‚îÄ js/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ main.js          # Main JavaScript
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ gallery.js       # Gallery JavaScript
‚îÇ       ‚îî‚îÄ‚îÄ images/
‚îÇ           ‚îî‚îÄ‚îÄ logo.png         # AGKS Logo
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt             # Python Dependencies
‚îú‚îÄ‚îÄ README.md                    # Project README
‚îî‚îÄ‚îÄ SETUP_GUIDE.md              # Installation Guide


================================================================================
                        BACKEND SERVICES (DETAILED)
================================================================================

--------------------------------------------------------------------------------
1. YOLO SERVICE (yolo_service.py) - AI Model Management
--------------------------------------------------------------------------------

PURPOSE: Manages the YOLOv8 deep learning model for object detection.

CLASS: YOLOService

METHODS:
- __init__(model_path): Initializes and loads the YOLO model from file
- load_model(): Loads YOLO model and extracts class names
- run_inference(frame, inference_size=320): Runs object detection on a frame
- get_detections(results): Extracts detection data from YOLO results
- annotate_frame(results): Draws bounding boxes on the frame
- get_model_info(): Returns model metadata

DETECTED CLASSES (Custom Trained):
- 0: Balaclava (Masked Face)
- 1: Gun
- 2: Knife
- 3: Money
- 4: Person
- 5: Phone

TECHNICAL DETAILS:
- Uses ultralytics YOLO library
- Default inference size: 320 pixels (for speed)
- Returns detection dictionaries with class name, confidence, and class ID

--------------------------------------------------------------------------------
2. CAMERA SERVICE (camera_service.py) - Video Capture Management
--------------------------------------------------------------------------------

PURPOSE: Manages camera hardware and video capture operations.

CLASS: CameraService

METHODS:
- __init__(camera_index=0, width=640, height=480): Initializes camera
- initialize_camera(): Configures camera with optimal settings
- read_frame(): Reads a single frame from camera
- is_opened(): Checks if camera is available
- get_camera_info(): Returns camera metadata (resolution, FPS)
- switch_camera(new_index): Switches to different camera
- cleanup(): Releases camera resources
- __del__(): Destructor to ensure cleanup

CAMERA SETTINGS:
- Resolution: 640x480 (optimized for streaming)
- Target FPS: 30
- Buffer Size: 1 (to reduce latency)
- Uses DirectShow (cv2.CAP_DSHOW) on Windows

FEATURES:
- Thread-safe with camera_lock
- Automatic reconnection on failure
- Multiple camera support (indices 0-5)

--------------------------------------------------------------------------------
3. RECORDER SERVICE (recorder_service.py) - Forensic Video Recording
--------------------------------------------------------------------------------

PURPOSE: Manages forensic video recording with pre-event and post-event capture.

CLASS: RecorderService

METHODS:
- __init__(alert_folder, pre_event_seconds=5, post_event_seconds=5, estimated_fps=20)
- add_frame_to_buffer(frame): Adds frame to ring buffer (for pre-event)
- can_record(): Checks if new recording is allowed (cooldown system)
- record_alert_video(threat_type, camera_service, yolo_service): Records alert
- get_buffer_status(): Returns buffer fill percentage

RECORDING FEATURES:
- Ring Buffer: Maintains ~40 frames (5 seconds) for pre-event recording
- Pre-Event Recording: Captures 5 seconds BEFORE the threat occurs
- Post-Event Recording: Records 5 seconds AFTER threat detection
- Cooldown System: 5 second minimum between recordings
- Output Format: MP4 with H.264 codec (x264)

HOW IT WORKS:
1. Continuously stores frames in ring buffer
2. When threat detected, copies buffer (pre-event frames)
3. Continues recording post-event frames with YOLO annotations
4. Saves complete video with bounding boxes visible

--------------------------------------------------------------------------------
4. TELEGRAM SERVICE (telegram_service.py) - Alert Notifications
--------------------------------------------------------------------------------

PURPOSE: Sends real-time threat notifications to Telegram.

CLASS: TelegramService

METHODS:
- __init__(bot_token, chat_id): Initializes with Telegram credentials
- send_photo_alert(frame, threat_type): Sends photo with threat caption
- _create_caption(threat_type): Generates formatted message
- send_text_message(message): Sends text-only message
- test_connection(): Tests bot connectivity

ALERT FORMAT:
üö® THREAT DETECTED: [Threat Type]
üïê Time: [Timestamp]
üìπ Forensic video saved locally

FEATURES:
- Sends threat snapshot as JPEG image
- Automatic timestamp in message
- 10-second timeout for reliability
- Uses Telegram Bot API

--------------------------------------------------------------------------------
5. THREAT LOGIC (threat_logic.py) - Threat Detection Algorithm
--------------------------------------------------------------------------------

PURPOSE: Implements the core threat detection logic and rules.

CLASS: ThreatLogic (Static Methods)

DETECTION RULES:

+------------------+--------------------+----------+
| Detected Objects |    Threat Type     | Severity |
+------------------+--------------------+----------+
| Balaclava        | Masked Person      |   HIGH   |
| Person + Gun     | Armed Person       |   HIGH   |
| Person + Knife   | Person with Knife  |   HIGH   |
| Gun alone        | NO THREAT          |    -     |
| Knife alone      | NO THREAT          |    -     |
| Person alone     | NO THREAT          |    -     |
+------------------+--------------------+----------+

KEY LOGIC:
- Balaclava (masked face) = ALWAYS a threat
- Weapons require PERSON presence to trigger alert
- Prevents false alarms from unmanned objects

METHODS:
- check_threat_conditions(detections): Main threat analysis
- get_threat_severity(threat_type): Returns severity level
- should_send_telegram_alert(threat_type): Determines notification
- get_threat_message(threat_type): Human-readable message
- get_detection_summary(detections): Logging summary

--------------------------------------------------------------------------------
6. DATABASE SERVICE (database_service.py) - Alert Storage
--------------------------------------------------------------------------------

PURPOSE: Manages persistent storage of threat alerts in SQLite.

CLASS: DatabaseService

================================================================================
          WHY WE USE SQLITE DATABASE - DETAILED EXPLANATION
================================================================================

WHAT IS SQLite?
SQLite is a lightweight, file-based relational database management system (RDBMS).
Unlike other databases (MySQL, PostgreSQL), SQLite stores the entire database in 
a single file on disk, making it ideal for embedded applications.

WHY WE CHOSE SQLite FOR THIS PROJECT:

1. SIMPLICITY
   - No separate server installation required
   - No configuration or administration needed
   - Database is a single file (alerts.db)
   - Works immediately without any setup

2. PORTABILITY
   - The entire database is one file
   - Easy to backup (just copy the file)
   - Easy to transfer between systems
   - Works on Windows, Linux, macOS

3. PERFORMANCE
   - Very fast for read operations
   - Excellent for applications with moderate write volume
   - Perfect for our use case (recording alerts)
   - No network overhead (local file access)

4. ZERO CONFIGURATION
   - No username/password setup
   - No port configuration
   - No separate database service to run
   - Just import sqlite3 and use

5. RELIABILITY
   - ACID compliant (Atomicity, Consistency, Isolation, Durability)
   - Crash-resistant with automatic recovery
   - Widely tested and stable

6. EMBEDDED IN PYTHON
   - sqlite3 is part of Python standard library
   - No pip install needed for SQLite
   - Always available in any Python installation

WHY NOT OTHER DATABASES?

MySQL/PostgreSQL:
- Requires separate server installation
- Requires running database service
- Needs configuration and maintenance
- Overkill for single-user application

MongoDB:
- Requires separate installation
- NoSQL might be unnecessary complexity
- SQLite is simpler for structured data

File-based (JSON/CSV):
- Not scalable for complex queries
- No transaction support
- Harder to maintain data integrity
- Slower for large datasets

--------------------------------------------------------------------------------
          DATABASE IMPLEMENTATION DETAILS
--------------------------------------------------------------------------------

DATABASE FILE LOCATION: backend/database/alerts.db

DATABASE SCHEMA:
+--------------+---------------+------------------+
|    Column    |     Type      |   Description    |
+--------------+---------------+------------------+
| id           | INTEGER PK    | Auto-increment   |
| timestamp    | DATETIME      | When detected    |
| threat_type  | VARCHAR(50)   | Type of threat   |
| camera_id    | INTEGER       | Camera index     |
| severity     | VARCHAR(20)   | High/Critical    |
| video_path   | VARCHAR(255)  | Path to video    |
| telegram_sent| BOOLEAN       | Notification sent|
| status       | VARCHAR(20)   | Alert status     |
+--------------+---------------+------------------+

COLUMN EXPLANATIONS:

- id: Unique identifier for each alert (auto-generated)
- timestamp: Exact date and time when threat was detected
- threat_type: What type of threat (e.g., "Masked Person Detected")
- camera_id: Which camera detected the threat (0, 1, 2, etc.)
- severity: Threat level (High, Critical)
- video_path: Location of recorded forensic video file
- telegram_sent: Whether Telegram notification was sent (True/False)
- status: Current status of alert (Recorded, Reviewed, etc.)

METHODS:
- __init__(db_path): Initializes database connection
- init_database(): Creates alerts table if not exists
- add_alert(...): Inserts new alert record
- get_all_alerts(limit, offset): Retrieves with pagination
- get_recent_alerts(limit): Gets latest alerts
- get_alerts_count(): Returns total and unread counts
- delete_alert(alert_id): Removes specific alert
- clear_all_alerts(): Deletes all alerts
- get_stats(): Database statistics

HOW DATA FLOWS INTO DATABASE:

1. Threat detected by YOLO model
2. ThreatLogic confirms it's a valid threat
3. RecorderService saves forensic video
4. TelegramService sends notification
5. DatabaseService.add_alert() is called with:
   - threat_type: "Masked Person Detected"
   - camera_id: 0
   - video_path: "storage/alerts/alert_Masked_Person_20251230.mp4"
   - telegram_sent: True/False
6. Alert is stored permanently in SQLite database

HOW DATA IS RETRIEVED:

- Alerts page loads ‚Üí calls /api/alerts endpoint
- Flask route calls DatabaseService.get_all_alerts()
- SQLite returns all alert records as list of dictionaries
- Frontend displays alerts in table format
- User can view, delete, or play associated videos

THREAD SAFETY:

The DatabaseService uses threading.Lock() to ensure that multiple threads
don't access the database simultaneously, preventing data corruption.

FEATURES:
- Thread-safe with Lock
- Automatic directory creation
- Row factory for dict-like access
- Pagination support


================================================================================
                         API ENDPOINTS (ROUTES)
================================================================================

The application exposes the following HTTP endpoints:

PAGE ROUTES:
+--------------+---------+----------------------------------+
|   Endpoint   | Method  |          Description             |
+--------------+---------+----------------------------------+
| /            | GET     | Dashboard (main page)            |
| /monitor     | GET     | Live monitoring page             |
| /alerts      | GET     | Alerts history page              |
| /gallery     | GET     | Video gallery page               |
| /settings    | GET     | System settings page             |
+--------------+---------+----------------------------------+

VIDEO STREAMING:
+----------------------+---------+------------------------------+
|      Endpoint        | Method  |        Description           |
+----------------------+---------+------------------------------+
| /video_feed/<mode>   | GET     | MJPEG video stream           |
+----------------------+---------+------------------------------+

API ENDPOINTS:
+------------------------+---------+-------------------------------+
|       Endpoint         | Method  |         Description           |
+------------------------+---------+-------------------------------+
| /logs                  | GET     | Get detection logs            |
| /threat_status         | GET     | Check active threat status    |
| /api/alerts/count      | GET     | Get alerts count              |
| /api/alerts/recent     | GET     | Get recent alerts             |
| /api/alerts            | GET     | Get all alerts                |
| /api/alerts/<id>       | DELETE  | Delete specific alert         |
| /api/alerts/clear      | DELETE  | Clear all alerts              |
| /api/detect_cameras    | GET     | Detect available cameras      |
| /api/switch_camera     | POST    | Switch camera source          |
| /api/videos            | GET     | List saved videos             |
| /video/<folder>/<name> | GET     | Serve video file              |
| /video/<folder>/<name> | DELETE  | Delete video file             |
+------------------------+---------+-------------------------------+


================================================================================
                         FRONTEND PAGES (DETAILED)
================================================================================

--------------------------------------------------------------------------------
1. DASHBOARD (dashboard.html)
--------------------------------------------------------------------------------

FEATURES:
- Hero section with AGKS logo and description
- System status banner (Online/Offline)
- Navigation cards to other pages:
  * Live Monitor - Real-time camera feed
  * Alerts - View threat history
  * Settings - Configure system

DESIGN:
- Dark gradient background
- Glassmorphism card design
- Fade-in animations
- Responsive grid layout

--------------------------------------------------------------------------------
2. LIVE MONITOR (monitor.html)
--------------------------------------------------------------------------------

FEATURES:
- Real-time MJPEG video stream with YOLO annotations
- Live detection logs (updated every 500ms)
- Threat status indicator
- Recording alert notification
- Camera selector dropdown

TECHNICAL:
- Uses <img> tag with MJPEG stream source
- Polls /logs and /threat_status endpoints
- Audio alarm on threat detection
- Auto-scrolling log container

--------------------------------------------------------------------------------
3. ALERTS PAGE (alerts.html)
--------------------------------------------------------------------------------

FEATURES:
- Paginated alerts table
- Severity indicators (color-coded)
- Video playback modal
- Individual alert deletion
- Clear all alerts button
- Alert statistics

COLUMNS:
- Timestamp, Threat Type, Severity, Camera, Status, Action

--------------------------------------------------------------------------------
4. SETTINGS PAGE (settings.html)
--------------------------------------------------------------------------------

FEATURES:
- Camera source selector
- Available cameras detection
- Camera switch functionality
- System information display

--------------------------------------------------------------------------------
5. GALLERY PAGE (gallery.html)
--------------------------------------------------------------------------------

FEATURES:
- Grid view of recorded videos
- Video thumbnails
- Video playback modal
- Storage usage statistics
- Video deletion support


================================================================================
                        CONFIGURATION (config.py)
================================================================================

YOLO CONFIGURATION:
- MODEL_PATH: models/best.pt
- CONFIDENCE_THRESHOLD: 0.5 (50%)
- INFERENCE_SIZE: 320 pixels

CAMERA CONFIGURATION:
- DEFAULT_CAMERA_INDEX: 0
- FRAME_WIDTH: 640
- FRAME_HEIGHT: 480

RECORDING CONFIGURATION:
- PRE_EVENT_SECONDS: 5 (seconds before threat)
- POST_EVENT_SECONDS: 5 (seconds after threat)
- ESTIMATED_FPS: 8 (matches actual YOLO processing speed)

TELEGRAM CONFIGURATION:
- TELEGRAM_ENABLED: True
- TELEGRAM_BOT_TOKEN: (your token)
- CHAT_ID: (your chat ID)

FOLDER PATHS:
- ALERT_VIDEO_FOLDER: backend/storage/alerts/
- STATIC_FOLDER: frontend/static/


================================================================================
                         THREAT DETECTION WORKFLOW
================================================================================

STEP-BY-STEP PROCESS:

1. CAMERA CAPTURE
   - CameraService reads frame from webcam
   - Frame buffered in ring buffer for pre-event

2. YOLO INFERENCE
   - Frame sent to YOLOService
   - Model detects objects (Balaclava, Gun, Knife, Person, etc.)
   - Returns detection boxes with confidence scores

3. THREAT ANALYSIS
   - ThreatLogic analyzes detected objects
   - Checks combination rules (e.g., Person + Gun)
   - Returns is_threat boolean and threat type

4. IF THREAT DETECTED:
   a. Add log entry to detection_logs
   b. Check RecorderService cooldown
   c. Start forensic video recording (background thread):
      - Save pre-event frames from buffer
      - Record 5 seconds post-event
      - Save as MP4 with annotations
   d. Send Telegram photo alert
   e. Save alert to database

5. FRAME ANNOTATION
   - Bounding boxes drawn on frame
   - Frame added to ring buffer
   - Annotated frame sent to MJPEG stream

6. STREAM OUTPUT
   - Frame encoded as JPEG
   - Sent to browser via MJPEG protocol
   - UI updates detection logs


================================================================================
                         DEPENDENCIES (requirements.txt)
================================================================================

Core Dependencies:
- Flask==3.1.2 (Web framework)
- opencv-python==4.12.0.88 (Computer vision)
- ultralytics==8.3.243 (YOLOv8)
- requests==2.32.5 (HTTP client for Telegram)
- numpy>=2.0 (Numerical computing)
- torch>=2.0 (PyTorch for YOLO)
- torchvision>=0.15 (Vision utilities)
- pillow>=10.0 (Image processing)


================================================================================
                              KEY FEATURES
================================================================================

1. REAL-TIME THREAT DETECTION
   - YOLOv8 deep learning model
   - 6 custom-trained classes
   - Sub-second detection speed

2. FORENSIC VIDEO RECORDING
   - Pre-event capture (5 seconds before)
   - Post-event capture (5 seconds after)
   - Videos saved with bounding boxes

3. TELEGRAM NOTIFICATIONS
   - Instant photo alerts
   - Threat details and timestamps
   - Remote monitoring capability

4. WEB DASHBOARD
   - Modern responsive design
   - Real-time MJPEG streaming
   - Alert management interface

5. MULTI-CAMERA SUPPORT
   - Automatic camera detection
   - Runtime camera switching
   - Multiple indices (0-5)

6. DATABASE LOGGING
   - SQLite persistent storage
   - Complete alert history
   - Statistics and filtering


================================================================================
                           INSTALLATION STEPS
================================================================================

1. Clone repository:
   git clone [repository-url]
   cd Project-V2

2. Create virtual environment:
   python -m venv venv
   venv\Scripts\activate  (Windows)

3. Install dependencies:
   pip install flask opencv-python ultralytics requests

4. Configure Telegram (optional):
   - Edit backend/app/config.py
   - Set TELEGRAM_BOT_TOKEN and CHAT_ID

5. Run application:
   cd backend
   python run.py

6. Access dashboard:
   Open http://localhost:5000


================================================================================
                              TROUBLESHOOTING
================================================================================

PROBLEM: "No module named 'flask'"
SOLUTION: Activate venv and install: pip install flask

PROBLEM: Camera not opening
SOLUTION: Close other apps using camera, try different index

PROBLEM: Slow video stream
SOLUTION: Lower inference size in config.py

PROBLEM: Videos playing too fast
SOLUTION: Adjust ESTIMATED_FPS to match actual processing speed

PROBLEM: Telegram alerts not sending
SOLUTION: Verify bot token and chat ID, check internet


================================================================================
                              FUTURE IMPROVEMENTS
================================================================================

- Multiple camera simultaneous monitoring
- Cloud storage integration
- Mobile application
- Email notifications
- Advanced analytics dashboard
- Person face recognition
- License plate detection


================================================================================
                                 CONCLUSION
================================================================================

AGKS (Akƒ±llƒ± G√∂zetim Koruma Sistemi) is a comprehensive AI-powered security 
surveillance system designed for real-time threat detection. The system combines 
state-of-the-art deep learning (YOLOv8) with robust video recording and instant 
notification capabilities. The modular architecture with separate services for 
camera, YOLO, recording, telegram, and database operations ensures maintainability 
and scalability.

The system is suitable for:
- Home security monitoring
- Small business surveillance
- Educational institutions
- Research and development purposes

================================================================================
                    Document Generated: December 30, 2025
                           AGKS Version 2.0
================================================================================
